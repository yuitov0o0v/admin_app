# DB
user_profileのポリシーがループしているのを治す
テスト時は手動でロールを設定して作業する
ユーザー情報のroleが設定されていない（新規作成の時にrole設定「アプリ側の新規作成はuserロール、管理者側は招待制にする予定」されるように作る）
Auth.userを使用したロール管理も視野に入れる
# UI
地図のレイヤーを最下層にし画面全体が地図になるようにする





## Supabaseでのロールベースアクセス制御（RLS）におけるベストプラクティス
`auth.users`テーブルにロール情報を保存するには、**`raw_app_meta_data`** という専用のカラムを利用します。

この方法は、ユーザー自身がロールを変更できないため安全で、RLSポリシーの無限ループ問題も解決できるベストプラクティスです。

-----

## なぜ `raw_app_meta_data` を使うのか？

  * **🔒 セキュリティ**: このカラムは、クライアント（ブラウザ）から直接変更できません。**サーバーサイド**から\*\*サービスロールキー（`service_role_key`）\*\*という管理者権限を使ってのみ更新できます。これにより、ユーザーが自分自身を管理者に昇格させるような不正を防げます。
  * **🚀 パフォーマンス**: ここに保存されたデータは、ユーザーがログインした際に発行される\*\*JWT（認証トークン）\*\*に自動的に含まれます。そのため、RLSポリシーが発動した際に、わざわざ他のテーブルを検索することなく、手元にあるトークンから瞬時にロール情報を読み取れます。

-----

## 設定方法：ステップ・バイ・ステップ

設定は大きく分けて「**① ロールを書き込む処理**」と「**② ロールを読み取る処理**」の2つです。

### ステップ1：ロール情報を書き込む（サーバーサイド）

ユーザーのロールを設定・更新する処理は、必ずサーバーサイドで行います。最も一般的な方法は**Supabase Functions**を利用することです。

#### 1\. Supabase Function を作成する

まず、ユーザーIDと設定したいロールを受け取って、`raw_app_meta_data`を更新するFunctionを作成します。

**`supabase/functions/set-user-role/index.ts` の例:**

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

// Supabaseプロジェクトの環境変数からAdminクライアントを初期化
const supabaseAdmin = createClient(
  process.env.SUPABASE_URL ?? '',
  // 🔴 必ず service_role_key を使う
  process.env.SUPABASE_SERVICE_ROLE_KEY ?? ''
)

Deno.serve(async (req) => {
  // POSTリクエストからuserIdとroleを取得
  const { userId, role } = await req.json();

  if (!userId || !role) {
    return new Response('User ID and role are required', { status: 400 });
  }

  // ユーザーのメタデータを更新
  const { error } = await supabaseAdmin.auth.admin.updateUserById(
    userId,
    {
      app_metadata: { 
        // 既存のメタデータを保持しつつroleを上書きしたい場合は、
        // 事前にユーザー情報を取得してマージする必要がある
        'role': role // 'admin', 'user' などの役割を保存
      }
    }
  );

  if (error) {
    return new Response(error.message, { status: 500 });
  }

  return new Response(JSON.stringify({ message: `Role updated to ${role}` }), {
    headers: { 'Content-Type': 'application/json' },
  });
});
```

#### 2\. 実行するタイミング

このFunctionは、以下のようなタイミングで呼び出します。

  * ユーザーが新規登録した直後（デフォルトの`user`ロールを設定）
  * 管理画面などから、特定のユーザーを管理者に昇格させる時

-----

### ステップ2：ロール情報を読み取る（データベース）

書き込まれたロール情報は、RLSポリシーやデータベース関数からJWTを通じて読み取ります。

#### 1\. ロール取得用の関数を作成する

以前の回答で提示した、JWTから`role`を安全に取得するための関数をデータベースに作成します。

**SQLエディタで実行:**

```sql
CREATE OR REPLACE FUNCTION get_my_role_from_jwt()
RETURNS TEXT
LANGUAGE sql
STABLE
AS $$
  -- 現在のJWTクレームをJSONB形式で取得し、
  -- app_metadataの中から'role'キーの値をテキストとして取り出す
  SELECT nullif(current_setting('request.jwt.claims', true)::jsonb -> 'app_metadata' ->> 'role', '')::text;
$$;
```

#### 2\. RLSポリシーで関数を利用する

この関数を使えば、`user_profile`テーブルなどを参照することなく、安全にアクセス制御ができます。

**`user_profile`テーブルの`SELECT`ポリシーの例:**

```sql
-- 自分のプロフィール、または管理者の場合は全員のプロフィールを閲覧できる
(user_id = auth.uid()) OR (get_my_role_from_jwt() = 'admin')
```

-----

## 全体の流れのまとめ

1.  **[書き込み]** **Supabase Function**（サーバー）が、特定のユーザーの`app_metadata`に`{ "role": "admin" }`を書き込む。
2.  **[認証]** そのユーザーがログインすると、発行されるJWTの中に`role: "admin"`という情報が含まれる。
3.  **[読み取り]** ユーザーがデータベースにアクセスすると、RLSポリシーが発動する。
4.  **[判定]** ポリシーが`get_my_role_from_jwt()`関数を呼び出し、JWTから`"admin"`という役割を読み取ってアクセスを許可する。

この方法で、安全かつ効率的にロールベースの権限管理を実装できます。👍




